{"ast":null,"code":"// import {checkForChecks} from \"../King activity/Checks\";\n// import isPiecePinned from \"./Check for pin\";\n// import pinFilter from \"./Piin filter\";\n// import canCastle from \"./Allow castling\";\n// import {nextMoves} from \"./NextMoves\";\n// import {coverMoves} from \"../Move piece/Related with king/Check situation\";\n// import {gameField} from \"../../Gamefield\";\n// export default function filterNextMoves(x, y){\n//     let [color, piece] = gameField[y][x]\n//     let newMoves = nextMoves.filter(([x,y])=>\n//         x >= 0 && x < 8\n//         && y >= 0 && y < 8\n//         && gameField[y][x][0] !== color\n//     )\n//     if (piece === \"K\"){\n//         newMoves = newMoves.filter(move => !checkForChecks(move))\n//         newMoves.push(...canCastle(x, y))\n//     }\n//     else if (piece === \"P\"){\n//         newMoves = newMoves.filter(([a, b]) => ! (a === x && gameField[b][a] !== \"0\"))\n//     }\n//     if (coverMoves.length && piece !== \"K\"){\n//         let saves = coverMoves.map(elm => elm.toString())\n//         newMoves = newMoves.filter(move => saves.includes(move.toString()))\n//     }\n//     if (isPiecePinned([x, y])){\n//         console.log(color + piece, \"is Pinned\")\n//         newMoves = newMoves.filter(move => pinFilter(move, [x,y]))\n//     }\n//     return newMoves\n// }","map":{"version":3,"names":[],"sources":["C:/Users/alapc/OneDrive/Documents/Programming/chess/src/Chessboard/Game/Pieces/Logic/Next moves/Filtration.js"],"sourcesContent":["// import {checkForChecks} from \"../King activity/Checks\";\r\n// import isPiecePinned from \"./Check for pin\";\r\n// import pinFilter from \"./Piin filter\";\r\n// import canCastle from \"./Allow castling\";\r\n// import {nextMoves} from \"./NextMoves\";\r\n// import {coverMoves} from \"../Move piece/Related with king/Check situation\";\r\n// import {gameField} from \"../../Gamefield\";\r\n\r\n// export default function filterNextMoves(x, y){\r\n\r\n//     let [color, piece] = gameField[y][x]\r\n\r\n//     let newMoves = nextMoves.filter(([x,y])=>\r\n//         x >= 0 && x < 8\r\n//         && y >= 0 && y < 8\r\n//         && gameField[y][x][0] !== color\r\n//     )\r\n\r\n//     if (piece === \"K\"){\r\n//         newMoves = newMoves.filter(move => !checkForChecks(move))\r\n//         newMoves.push(...canCastle(x, y))\r\n//     }\r\n\r\n//     else if (piece === \"P\"){\r\n//         newMoves = newMoves.filter(([a, b]) => ! (a === x && gameField[b][a] !== \"0\"))\r\n//     }\r\n\r\n//     if (coverMoves.length && piece !== \"K\"){\r\n//         let saves = coverMoves.map(elm => elm.toString())\r\n//         newMoves = newMoves.filter(move => saves.includes(move.toString()))\r\n//     }\r\n\r\n//     if (isPiecePinned([x, y])){\r\n//         console.log(color + piece, \"is Pinned\")\r\n//         newMoves = newMoves.filter(move => pinFilter(move, [x,y]))\r\n//     }\r\n\r\n//     return newMoves\r\n\r\n// }"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA"},"metadata":{},"sourceType":"module"}